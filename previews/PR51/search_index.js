var documenterSearchIndex = {"docs":
[{"location":"ellipsisnotation/#API","page":"API","title":"API","text":"","category":"section"},{"location":"ellipsisnotation/","page":"API","title":"API","text":"Modules = [EllipsisNotation]","category":"page"},{"location":"ellipsisnotation/#EllipsisNotation.:..","page":"API","title":"EllipsisNotation.:..","text":"Implementation of the notation .. for indexing arrays. It's similar to the Python ... in that it means 'all of the columns before (or after)'.\n\n.. slurps dimensions greedily, meaning that the first occurrence of .. in an index expression creates as many slices as possible. Other instances of .. afterwards are treated simply as slices. Usually, you should only use one instance of .. in an indexing expression to avoid possible confusion.\n\nExample\n\njulia> A = Array{Int}(undef,2,4,2);\n\njulia> A[..,1] = [2 1 4 5\n                  2 2 3 6];\n\njulia> A[..,2] = [3 2 6 5\n                  3 2 6 6];\n\njulia> A[:,:,1] == [2 1 4 5\n                    2 2 3 6]\ntrue\n\njulia> A[1,..] = reshape([3 4\n                          5 6\n                          4 5\n                          6 7],1,4,2) # drops singleton dimension\n...\n\njulia> B = [3 4\n            5 6\n            4 5\n            6 7];\n\njulia> B == reshape(A[1,..],4,2)\ntrue\n\n\n\n\n\n","category":"constant"},{"location":"#EllipsisNotation.jl","page":"Home","title":"EllipsisNotation.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"EllipsisNotation.jl implements the notation .. for indexing arrays. It's similar to the Python ... in that it means 'all of the columns before (or after)'.","category":"page"},{"location":"","page":"Home","title":"Home","text":".. slurps dimensions greedily, meaning that the first occurrence of .. in an index expression creates as many slices as possible. Other instances of .. afterwards are treated simply as slices. Usually, you should only use one instance of .. in an indexing expression to avoid possible confusion.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pkg.add(\"EllipsisNotation\")\nusing EllipsisNotation","category":"page"},{"location":"#Example-Usage","page":"Home","title":"Example Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> A = Array{Int}(undef,2,4,2)\n\njulia> A[..,1] = [2 1 4 5\n                 2 2 3 6]\n\njulia> A[..,2] = [3 2 6 5\n                  3 2 6 6]\n\njulia> A[:,:,1] == [2 1 4 5\n                    2 2 3 6]\ntrue\n\njulia> A[1,..] = reshape([3 4\n                          5 6\n                          4 5\n                          6 7],1,4,2) # drops singleton dimension\n\njulia> B = [3 4\n            5 6\n            4 5\n            6 7]\n\njulia> B == reshape(A[1,..],4,2)\ntrue\n\njulia> A[..,1,2] # Can do as many integers as you want on the end!","category":"page"},{"location":"","page":"Home","title":"Home","text":"For avoiding squeezing dimensions from slicing.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> C = ones(3,3,3,3,3);\njulia> size(C[1:1, .., 1:1])\n(1, 3, 3, 3, 1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note: .. slurps dimensions greedily, meaning that the first occurrence of .. in an index expression creates as many slices as possible. Other instances of .. afterwards are treated simply as slices. Usually, you should only use one instance of .. in an indexing expression to avoid possible confusion.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Warning: .. does not work when indexing also with end or begin. For example, A = randn(2,3,4); A[.., 1:end] will not give the intended result. This is a known limitation, and is not likely to be fixed until some necessary changes in the Julia language itself are implemented. See https://github.com/ChrisRackauckas/EllipsisNotation.jl/issues/19 for more details.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages for guidance on PRs, issues, and other matters relating to contributing to SciML.\nSee the SciML Style Guide for common coding practices and other style decisions.\nThere are a few community forums:\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Slack\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Zulip\nOn the Julia Discourse forums\nSee also SciML Community page","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"I would like to acknowledge M. Schauer for the .. notation implementation. He had the original idea, I just extended it and put it into a package because of how useful it has been to me.","category":"page"}]
}
